run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
library(processx)
library(fs)            # just for path_expand(); not compulsory
bin        <- path_expand("~/Downloads/gbacpp-0.2.0/build/bin/find_optimum")
model_root <- path_expand("~/Downloads/gbacpp-0.2.0/examples/toy_models")
out_dir    <- path_expand("~/Downloads/gbacpp-0.2.0/examples/output")
## sanity checks ------------------------------------------------------------
stopifnot(file_exists(bin))          # fails early if you forgot to compile
Sys.chmod(bin, "0755")               # makes sure it is executable (Unix/Mac)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "A",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
library(processx)
library(fs)            # just for path_expand(); not compulsory
bin        <- path_expand("~/Downloads/gbacpp-0.2.0/build/bin/find_optimum")
model_root <- path_expand("~/Downloads/gbacpp-0.2.0/examples/toy_models")
out_dir    <- path_expand("~/Downloads/gbacpp-0.2.0/examples/output")
## sanity checks ------------------------------------------------------------
stopifnot(file_exists(bin))          # fails early if you forgot to compile
Sys.chmod(bin, "0755")               # makes sure it is executable (Unix/Mac)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "ExtendedModel",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
library(processx)
library(fs)            # just for path_expand(); not compulsory
bin        <- path_expand("~/Downloads/gbacpp-0.2.0/build/bin/find_optimum")
model_root <- path_expand("~/Downloads/gbacpp-0.2.0/examples/toy_models")
out_dir    <- path_expand("~/Downloads/gbacpp-0.2.0/examples/output")
## sanity checks ------------------------------------------------------------
stopifnot(file_exists(bin))          # fails early if you forgot to compile
Sys.chmod(bin, "0755")               # makes sure it is executable (Unix/Mac)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
bin        <- path_expand("~/Downloads/gbacpp-0.2.1/build/bin/find_optimum")
model_root <- path_expand("~/Downloads/gbacpp-0.2.0/examples/toy_models")
out_dir    <- path_expand("~/Downloads/gbacpp-0.2.0/examples/output")
## sanity checks ------------------------------------------------------------
stopifnot(file_exists(bin))          # fails early if you forgot to compile
Sys.chmod(bin, "0755")               # makes sure it is executable (Unix/Mac)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
library(processx)
library(fs)            # just for path_expand(); not compulsory
bin        <- path_expand("~/Downloads/gbacpp-0.2.1/build/bin/find_optimum")
model_root <- path_expand("~/Downloads/gbacpp-0.2.1/examples/toy_models")
out_dir    <- path_expand("~/Downloads/gbacpp-0.2.1/examples/output")
## sanity checks ------------------------------------------------------------
stopifnot(file_exists(bin))          # fails early if you forgot to compile
Sys.chmod(bin, "0755")               # makes sure it is executable (Unix/Mac)
## run the optimisation -----------------------------------------------------
run(
bin,
args = c("-path", model_root,
"-name", "EX",
"-condition", "all",        # "all", "2", "3", … also valid
"-output", out_dir,
"-print"),
echo = TRUE                        # streams solver stdout/stderr to R console
)
# Clear variables
rm(list=ls(all=TRUE))
require('rstudioapi')
require('readODS')
require('nloptr')
require('Matrix')
require('MASS')
require('lpSolve')
directory <- dirname(getActiveDocumentContext()$path)
setwd(directory)
modelname <- "ExtendedModel"
source("Readmodelods.R")
source("Kinetics_rxn.R")
##Charles solver
source("GBACPP_solver.R")
# Clear variables
rm(list=ls(all=TRUE))
require('rstudioapi')
require('readODS')
require('nloptr')
require('Matrix')
require('MASS')
require('lpSolve')
directory <- dirname(getActiveDocumentContext()$path)
setwd(directory)
modelname <- "ExtendedModel"
source("Readmodelods.R")
source("Kinetics_rxn.R")
##Charles solver
source("GBACPP_solver.R")
f0
# Clear variables
rm(list=ls(all=TRUE))
require('rstudioapi')
require('readODS')
require('nloptr')
require('Matrix')
require('MASS')
require('lpSolve')
directory <- dirname(getActiveDocumentContext()$path)
setwd(directory)
modelname <- "ExtendedModel"
source("Readmodelods.R")
source("Kinetics_rxn.R")
##Charles solver
source("GBACPP_solver.R")
source("GBA_solver.R")
##Charles solver
source("GBACPP_solver.R")
source('f0.R')
# starts loop for the optimization at each environmental condition #############
f_opt  <- matrix(rep(0,r*n_conditions),ncol=r)
mu_opt <- rep(0,n_conditions)
otime  <- rep(0,n_conditions)
conv   <- rep(0,n_conditions)
iter   <- rep(0,n_conditions)
lambda <- rep(0,n_conditions)
A_rho  <- rep(0,n_conditions)
dmu_opt  <- matrix(rep(0,r*n_conditions),ncol=r)
for (cond in 1:n_conditions) {
rho <- rho_cond[cond]
x  <- x_cond[,cond]
# Upper bounds
upper_f <- rep(1000,r)
# lower bounds
lower_f <- rep(-1000,r)
# Optimization
solver      <- "SLSQP" # Local solvers: "COBYLA", "LBFGS", "MMA", or "SLSQP"
# measuring the total optimization time
st <- system.time({
# optimization (by default the function auglag minimizes, so we use
# negative_mu instead of mu as the objective function)
res <- auglag(f0, fn = negative_mu, gr = negative_dmu, lower = lower_f,
upper = upper_f, heq = g, heqjac = dg, hin = h,hinjac = dh,
localsolver = c(solver), localtol = 1e-8,
control = list(maxeval = 1000))
})
# solution
f0 <- res$par
# solution
f_opt[cond,] <- f0
# optimal mu
mu_opt[cond] <- mu(f0)
# convergence (codes: "-1" means optimization problem, "5" means optimization
# stop because maxeval, "4" means optimization stopped because xtol_rel or
# xtol_abs (above) was reached)
conv[cond] <- res$convergence
# optimization time
otime[cond] <- signif(st[[1]], digits= 4)
# number of iterations
iter[cond] <- res$iter
print(paste("optimization: ",cond, "/", n_conditions,", optimization time: ",
otime[cond]," s, convergence: ", conv[cond],", growth rate: ",
signif(mu_opt[cond], digits= 3), sep=""))
# lambda
lambda[cond] <- c(t(f0)%*%E(f0)%*%f0)*(mu(f0)^2)/b(f0)[p]
# Growth adaptation coefficient with respect to the density rho
A_rho[cond]  <- -lambda[cond]/mu(f0)
# Gj at fy0
for (j in 1:r) dmu_opt[cond,j] <- Gj(f0,j)
}
# solution
f0 <- res$par
###Implementation
library(processx)
library(readr)
library(withr)
library(fs)
library(tibble)
library(dplyr)
# mu ############## (growth rate)
mu <- function(f) as.numeric(M[p,r]*f[r]/(tau(ci(f))%*%f))
# negative mu (for minimization)
negative_mu <- function(f) -as.numeric(M[p,r]*f[r]/(tau(ci(f))%*%f))
# fluxes
v <- function(f) as.vector(mu(f))*rho*f
# protein concentrations
prot <- function(f) tau(ci(f))*v(f)
# internal concentrations "i" of metabolites "m" and proteome "p"
ci <- function(f) rho*M%*%f
# biomass fractions
b <- function(f) M%*%f
g <- function(f) sM%*%f - 1
h <- function(f) c(ci(f), rho*tau(ci(f))*f)
E <- function(f) rho*dtau(ci(f))%*%M
negative_dmu <- function(f) -((mu(f)^2)/b(f)[p])*(M[p,]/mu(f) -
t(f)%*%(rho*dtau(ci(f))%*%M) - tau(ci(f)))
dg	<- function(f) sM
# rows = c1, c2,...,p1,p2... , columns = d/df1, d/df2, ...
dh	<- function(f) rho*rbind(M,rho*(dtau(ci(f))%*%M*matrix(rep(f,r),nrow=r)) +
diag(r)*tau(ci(f)) )
# Equation of motion for reaction j (Gj = 0 at optimality) #####################
Gj <- function(f,j) M[p,j] + mu(f)*(- tau(ci(f))[j] - t(f)%*%(E(f)[,j])
+ c(t(f)%*%E(f)%*%f)*sM[j])
# f as a function of the independent fy ########################################
f <- function(fy) c(1/sM[1] - sM[-1]%*%fy,fy)
# f1 as a function of fy #######################################################
f1 <- function(fy) (1 - sM[-1]%*%fy)/sM[1]
# -------------------------------------------------------------------------
# bin         : full path to build/bin/find_optimum (or find_optimum.exe)
# model_tables: a named list of data frames, e.g. list(M = df1, kcat = df2, ...)
# condition   : 1, 2, 3, ... or "all"
# -------------------------------------------------------------------------
run_gbacpp <- function(bin, model_tables, condition = 1)
{
stopifnot(file_exists(bin))
## ---- 1. create ephemeral input hierarchy ------------------------------
tmp_root <- local_tempdir()             # disappears when function exits
tmp_out  <- local_tempdir()             # same for output
model_name <- "tmpmodel"
model_dir  <- dir_create(file.path(tmp_root, model_name))
# # write every element of the list as <name>.csv
# for (nm in names(model_tables)) {
#   write_csv2(model_tables[[nm]],
#             file.path("~/Downloads/gbacpp-0.2.0/examples/toy_models/", paste0(nm, ".csv")),)
# }
write_semicolon_csv <- function(df, file) {
# 1. build the header line:
header <- paste(c("", colnames(df)), collapse = ";")
# 2. build each row as a ';'-joined string:
rows <- vapply(seq_len(nrow(df)), function(i) {
vals <- df[i, , drop = TRUE]
# turn NAs into empty strings, else as.character() for numbers/strings
s <- ifelse(is.na(vals), "", as.character(vals))
paste(c(rownames(df)[i], s), collapse = ";")
}, character(1), USE.NAMES = FALSE)
# 3. write them out
writeLines(c(header, rows), con = file)
}
for (nm in names(model_tables)) {
write_semicolon_csv(
model_tables[[nm]],
file.path(model_dir, paste0(nm, ".csv"))
)
}
## ---- 2. run the optimiser ---------------------------------------------
res <- run(
bin,
args = c("-path",      tmp_root,
"-name",      model_name,
"-condition", as.character(condition),
#"-output",    out_dir,
"-output",    tmp_out,
"-print"),
echo = FALSE
)
out_files <- dir_ls(tmp_out, regexp = paste0(model_name, "_.*_optimum\\.csv$"))
results   <- vector("list", length(out_files))
# read them in, suppressing spec messages:
for (i in seq_along(out_files)) {
results[[i]] <- read_delim(
out_files[i],
delim           = ";",
trim_ws         = TRUE,
show_col_types  = FALSE
)
}
# 6. name each element by the middle bit of the filename
#    e.g. "tmpmodel_1_b_optimum.csv" → "1_b_optimum"
fnames <- path_file(out_files)
cleaned <- sub(
paste0("^", model_name, "_(.*)\\.csv$"),
"\\1",
fnames
)
names(results) <- cleaned
list(
optima = results,   # a named list of data.frames
log    = res$stdout # solver stdout (if you need it)
)
}
bin <- path_expand("~/Downloads/gbacpp-0.2.1/build/bin/find_optimum")
rownames(KI)=reactant
rownames(K)=reactant
f00=as.data.frame(f0)
rownames(f00)=reaction
df_cond <- as_tibble(conditions_matrix) %>%
column_to_rownames(var = "...1") %>%    # promote the first column to rownames
mutate(across(everything(), ~ as.numeric(trimws(.))))  # convert to numeric
model_tables <- list(
M          = as.data.frame(Mtotal),
kcat       = as.data.frame(kcat_matrix),
K          = as.data.frame(K),
KI       =as.data.frame(KI),
f0         =f00,
#f0         =df_f0,
conditions = df_cond           # + any optional sheets your model needs
)
# starts loop for the optimization at each environmental condition #############
f_opt  <- matrix(rep(0,r*n_conditions),ncol=r)
mu_opt <- rep(0,n_conditions)
otime  <- rep(0,n_conditions)
conv   <- rep(0,n_conditions)
iter   <- rep(0,n_conditions)
lambda <- rep(0,n_conditions)
A_rho  <- rep(0,n_conditions)
dmu_opt  <- matrix(rep(0,r*n_conditions),ncol=r)
for (cond in 1:n_conditions) {
rho <- rho_cond[cond]
x  <- x_cond[,cond]
ans <- run_gbacpp(bin, model_tables, condition = cond)
# solution
#f0 <- res$par
foptsol <- ans[["optima"]][[paste0(cond, "_f_optimum")]]
# option A: as numeric, with names preserved
res_vec <- as.numeric(foptsol[ , -1])
# solution
f_opt[cond,] <- res_vec
# optimal mu
mu_opt[cond] <- mu(res_vec)
# convergence (codes: "-1" means optimization problem, "5" means optimization
# stop because maxeval, "4" means optimization stopped because xtol_rel or
# xtol_abs (above) was reached)
conv[cond] <- ans[["optima"]][[paste0(cond, "_state_optimum")]][["converged"]]
# optimization time
otime[cond] <- ans[["optima"]][[paste0(cond, "_state_optimum")]][["run_time"]]
# number of iterations
iter[cond] <- ans[["optima"]][[paste0(cond, "_state_optimum")]][["doubling_time"]]
print(paste("optimization: ",cond, "/", n_conditions,", optimization time: ",
otime[cond]," s, convergence: ", conv[cond],", growth rate: ",
signif(mu_opt[cond], digits= 3), sep=""))
# lambda
lambda[cond] <- c(t(res_vec)%*%E(res_vec)%*%res_vec)*(mu(res_vec)^2)/b(res_vec)[p]
# Growth adaptation coefficient with respect to the density rho
A_rho[cond]  <- -lambda[cond]/mu(res_vec)
# Gj at fy0
for (j in 1:r) dmu_opt[cond,j] <- Gj(res_vec,j)
}
f0
# Clear variables
rm(list=ls(all=TRUE))
require('rstudioapi')
require('readODS')
require('nloptr')
require('Matrix')
require('MASS')
require('lpSolve')
directory <- dirname(getActiveDocumentContext()$path)
setwd(directory)
modelname <- "ExtendedModel"
modelname <- "BaseModel"
source("Readmodelods.R")
source("Kinetics_rxn.R")
source("GBA_solver.R")
##Charles solver
source("GBACPP_solver.R")
# Clear variables
rm(list=ls(all=TRUE))
require('rstudioapi')
require('readODS')
require('nloptr')
require('Matrix')
require('MASS')
require('lpSolve')
directory <- dirname(getActiveDocumentContext()$path)
setwd(directory)
modelname <- "D"
source("Readmodelods.R")
source("Kinetics_rxn.R")
##Charles solver
source("GBACPP_solver.R")
# Clear variables
rm(list=ls(all=TRUE))
require('rstudioapi')
require('readODS')
require('nloptr')
require('Matrix')
require('MASS')
require('lpSolve')
directory <- dirname(getActiveDocumentContext()$path)
setwd(directory)
modelname <- "A"
source("Readmodelods.R")
source("Kinetics_rxn.R")
##Charles solver
source("GBACPP_solver.R")
shiny::runApp('~/Downloads/gba-main/CGSapp/GBApp')
runApp('~/Downloads/gba-main/CGSapp/GBApp')
runApp('~/Downloads/gba-main/CGSapp/GBApp')
runApp('~/Downloads/gba-main/CGSapp/GBApp')
runApp('~/Downloads/gba-main/CGSapp/GBApp')
runApp('~/Downloads/gba-main/CGSapp/GBApp')
runApp('~/Downloads/gba-main/CGSapp/GBApp')
runApp('~/Downloads/gba-main/CGSapp/GBApp')
runApp('~/Downloads/gba-main/CGSapp/GBApp')
